# Welcome!
Hello! I am Jerry Yang, currently majoring in Computer Science and Finance!
See more information below!
## Resume
Click [here!](resume.pdf) for my resume!
## Project Demos
### Software

Pizza Ordering System:
![](pizza.mp4)

Using Java's abstract classes as well as Polymorphism, I developed a GUI using JavaFX which enabled the
users to order Pizza from a Pizza Store. The user is able to choose from the menu as well as build their own
from the various topping choices given to the user. When nished, the user is able to open their order on a
separate window and proceed to conrm their order, go back to the menu, or clear the order entirely.





BMI Calculator:

![](bmi.mp4)

I Developed an Android App through the use of Android Studio. It calculates the BMI and gives proper advice
based on on the Department of Health and Human Services. The app allows users to enter their weight and
height in either customary or metric units. The activity will then shift depending on whether or not the user
wants advice from the app.


### Simulation

Cache Simulator:

I created a Cache simulator using C, simulated an L1 cache using the Least Recently Used(LRU) replacement
algorithm, and included an option to incorporate prefetching


### Programming Projects

I toyed around with various different programming languages in a series of programs in order to get a feel for the different kinds of programming including but not limited to functional, logical, and dynamic programming. I covered a large number of topics from BSTs and Huffman Trees to regex and automatas. 

Here are just some of the samples!


![](haskell1.png)
Using Haskell to work with functional programing, I worked with huffman trees. "codes" returns a list of every element in the tree along with its encoding as a sequence of bits, while decode takes in a huffman tree and a stream of bits and "decodes" it, giving the string of symbols encoded, as well as a boolean indicating whether or not any bits were left over.



![](haskell2.png)
Utilizing Haskell, I built a series of Deterministic finite automatons. As shown in the sample, the first DFA accepts any language over {A,B,C} where every non-final A is followed by a B, every non-final B is followed by a C, and so forth. The second accepts the string as long as it contains the sequence "AB" or "BA" somewhere in the string.



![](prolog.png)
Using Prolog to work with logical programing, I worked with BSTs and lists. "bst" checks whether or not the input binary search tree is semi-deterministic. "zip" zips the elements of the first input with the second input and places it in the third as a list. The third list is always shorter or as long as the first two lists as extra elements are discarded. "insert" inserts an element into a list and stores it in the third list. 



